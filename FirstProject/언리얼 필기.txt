23-08-16

씬 컴포넌트는 트렌스폼이 있다. -> 배치 가능, 출력은 아님.
엑터 컴포넌트는 트렌스폼이 없다. -> 배치 불가, 기능 위주.

블루프린트는 c++클래스를 상속받을 수 있다.
블루프린트가 블루프린트 클래스를 상속받을 수도 있다.
c++는 블루프린트 상속받는게 안된다.

## 블루프린트
구조체 - C++처런 함수는 정의 못하고 데이터만
메크로 라이브러리 - #define 같은 함수를 붙여넣는등..

construction script : 생성자 역할, 소멸자는 따로 없음.

부모의 가상함수를 재정의(오버라이드)할 수있음.

construction script는 배치하면 바로 실행. 갱신할때마다 매번 호출됨. 생성자 아님. 에디터 타임에도 실행.
실행 전에도 동작하기때문에 모든 기능에 접근할 수는 없음.

beginplay는 플레이 시작 할때. 플레이가 아니면 실행 안됨.


틱 이벤트는 매 프레임 실행.


노드에는 데이터핀, 실행핀이 있다.

----------

캐릭터를 상속받아 만들면 쉽지만 성능이 떨어짐. 폰을 상속받아서 직접 구현하는게 좋을 수도.
다수의 인공지능 캐릭터가 필요한 경우, 캐릭터 상속을 받으면 성능이 매우 떨어질 수 있음. (ex. 핵앤슬래쉬)
캐릭터 클래스의 코드를 보고 필요한 부분만 따와서 만들 수도 있음.



월드 - 레벨. 레벨은 월드의 하위개념. 월드에 여러개의 레벨이 배치될 수 있음. 
GameMode는 월드에 적용되는 것. 월드당 게임모드 하나.


config, 콘텐츠, source, 언리얼 프로젝트 파일 삭제하면 안됨. 나머지는 자동으로 생김.






캐릭터 블루프린트에 캐릭터 무브먼트는 액터 컴포넌트로 위치 정보가 없어 기능만 동작하고 계층구조에 포함되지는 않는다.


특정월드에서 게임모드를 다르게 하고 싶으면 셋팅->월드셋팅->Gmae Mode->게임모드 오버라이드 사용



축 매핑은 매프레임, 액션 매핑은 누를때 땔대 이벤트 발생


입력맵핑 컨텍스트의 경우 같은 맵팅안에서 모디파이어는 값이 누적시키는게 아님
 
Add Contriller Yaw Input의 경우 회전시키는 대상이 플레이어 컨트롤러인데 이때 빙의한 캐릭터 설정에
폰->컨트롤러 회전 체크가 해제되어 있으면 캐릭터는 회전하지 않고 컨트롤러만 회전된다.



몽타주는 재생이되면 설정된 몽타주가 아니면 소스가 재생됨.
애니 몽타주의 슬롯이름과 보락색 그 이름이 같아야함


타입이름 전치사 A : 액터, U : uobject, F : 구조체, E : 열거형
UCLASS()는 모든 언리얼 엔진 코드에 붙어있음, 공식홈피에 표로 기능정리되있음
GENERATED_BODY() 모든 코드의 공통사항이 매크로로 정의되어있음

c++클래스를 만들때 부모 클래스 선택에서 '없음'을 선택해서 만들면 메모리관리를 직접해야함.
또한 이 클래스는 다른 언리얼 객체를 가져와 사용할 수 없어서 빈 클래스가 필요하면 Uobject를 상속
받는게 보통


퍼블릭은 보통 모듈 외부로 익스포트할때 사용함. 그냥 게임 만들때는 퍼블릭 프라이빗 만들어서
생성 안해도 됨.
dll로 만들어지는건 cpp, 헤더는 include로 따로 빼야함. 

제작한 코드 헤더의 *.generated.h 는 언리얼이 코드를 분석해서 자동으로 만들어주는 것

언리얼은 유니코드 문자열을 사용. 문자열 관련해서 단순히 " "이런 식의 사용 x, TEXT("")

... -> 가변인자. 인자의 개수가 정해지지 않음을 의미.


-------------------------------------
스마트 포인터

ObjPtr은 내부에 refcount가 있어서 참조가 생기면 카운트가 증가함.
누군가 참조를 지우면 카운트가 감소함. 카운트가 0이 됬을때 메모리를 반환.
참조가 하나라도 있으면 메모리를 반환하지 않는다는 것. 댕글링 포인터 방지.

-----------------------------------------
코드에서 에셋을 로드하기

1. 생성자에서만 사용가능한 방법

* 생성자다 보니 객체가 만들어질때 바로 로드됨.


2. 런타임에 사용가능한 방법




-------------------------------

화면에 출력을 하는 에셋(메쉬등)은 각각을 따로 가지는건 비효율 적이기때문에
하나를 원점을 기준으로 가지고 있다가 출력을 원하는 위치에 출력만 시키는 방식..

에디터를 열었을때 보이는 에셋은 이미 불러와저 있는 상태. 하지만 실행 파일은 에디터 처럼 미리 만들어 놓은게
아님. 실행할때 로딩이 되는 방식.

-------------------------------

구조체 내부 구조체를 접근할때도 ::을 사용한다.
ConstructorHelpers::FObjectFinder

-------------------------------

입력관련 처리는 폰이나 캐릭터가 아니라 플레이어 컨트롤러에서 처리하는게 맞음. 
빙의 시스템 특징상.

-------------------------------

오브젝트 레퍼런스는 만들어진 객채를 가져와서 쓰는것.
클래스 레퍼런스는 그런 타입임을 나타내는 것.

뒤에 _C가 붙으면 클래스 레퍼런스 라는 것. !!문자열 경로여도 마찬가지!!

-------------------------------

블루프린트도 에셋 취급.

-------------------------------

UPROPERTY는 멤버 변수마다 설정할 수 있음.. 유니티의 [ ] 같은 느낌?1

CreateDefaultSubobject는 생성자에서만 호출 가능

-------------------------------

언리얼 객체는 형변환 할때 Cast<>()를 사용해야함. 기본 자료형은 상관없음.
APlayerCharacter* Player = Cast<APlayerCharacter>(TryGetPawnOwner());

-------------------------------
언리얼의 충돌은 채널과 프로파일 크게 두가지.

오브젝트 채널은 실제 물체들에 지정하는 채널, 트레이스 채널은 물리적은 형태는 없는 경우들.. 카메라에 보이는지 카메라 물체 충돌등..

프로파일상 서로 하나라도 무시관계라면 충돌X.
둘다 오버랩이면 처음 충돌하는 순간과 떨어지는 순간을 판단해줌 겹칠수있음.

충돌의 쿼리 관련해서 알아보기.

Hit는 블록 상태일때 발생함. 그래서 오버랩과 히트 이벤트를 같이 사용할 이유는 없음.
오버랩은 양쪽다 겹칩 허용을 해야하지만 히트는 나만 해도 이벤트가 발생함. 

이런 이벤트를 C++로 할려면 함수를 만들고 함수 포인터 등록을 해야함.
-------------------------------

델리게이트 : 함수 포인터 시스템. 델리게이트에 함수를 등록해 두고 해당 상황이 발생하면
등록된 함수를 호출.

객체와 멤버함수의 주소를 등록해서 사용.



언리얼엔진 델리게이트 시스템.
UObject를 상속받은 얼리얼 클래스를 이용해서 생성한 객체의 멤버함수를 등록해놓고 
필요할 때 호출해주는 기능이다.

멤버함수는 UFUCTION으로 되어 있어야 한다.

#define을 이용하여 Macro를 제작하여 구성되어 있다.
인자는 0-9개 까지 #define이 따로 제작되어 있고 리턴타입이 있냐 없냐로도 구분된다.

Singlecast : 함수 1개를 지정해놓고 호출하게 한다.

Multicast : 함수 여러개를 등록할 수 있고 등록된 모든 함수들을 한번에 호출해줄 수 있게 해준다.

Dynamic : 직렬화가 가능해져서 블루프린트에서 사용이 가능해진다.


델리게이트 매크로는 델리케이트 구조체 타입 하나를 만들어주는 것이다.
해당 구조체를 이용해서 아래의 함수들을 활용하여 함수를 등록할 수 있다.

Bind() : 기존 델리게이트에 바인딩한다.

BindStatic() : 일반 C++ 전역 함수를 델리게이트에 바인딩해준다.

BindRaw() : 일반 C++ 객체를 이용하여 멤버함수를 바인딩해준다. 단, 등록한 객체가 제거되어 댕글링 포인터가 발생한 경우 안전하지 않을 수 있다.

BindSP() : 공유 포인터 기반의 함수를 바인딩한다. ExecuteIfBound() 함수를 이용해서 바인딩된 함수를 호출한다.

BindUObject() : UObject를 상속받은 클래스의 멤버함수를 바인딩한다. ExecuteIfBound() 함수를 이용해서 바인딩된 함수를 호추한다.

UnBind() : 바인딩을 해제한다.

IfBound() : 델리게이트에 함수가 바인딩 되었는지 판단한다. (예외처리등에 사용)

Execute() : 바인딩된 함수를 호출한다. 바인딩이 없을 경우 문제가 발생할 수 있기 때문에 IsBound() 함수를 이용해서 예외처리 후에 사용하는것이 안전하다.

ExecuteIfBound() : 반환값이 없는 델리게이트를 호출할 수 있다.


사용 예)
if(Delegate.IsBound())
	Delegate.Execute();



- Dynamic

BindDynamic() : SinglecCast + Dynamic 조합을 이용해서 생성한 델리게이트 함수를 바인딩하기 위한 함수이다.

AddDynamic() : MultiCast + Dynamic 조합을 이용해서 생성한 델리게이트에 함수를 바인딩하기 위한 함수이다.

RemoveDynamic() : NultiCast + Dynamic 조합을 이용해서 생성한 델리게이트에 바인딩된 함수를 제거해주기 위한 함수이다.



- Mulricast

Add() : 델리게이트에 함수를 추가한다.

AddStatic() : 일반 C++ 전역함수를 델리게이트에 추가한다.

AddRaw() : 일반 C++ 클래스 멤버함수를 객체와 함께 델리게이트에 추가한다.

AddSP() : 공유 포인터 기반 멤버함수를 델리게이트에 추가한다.

AddUObject() : UObject를 상속받은 클래스의 멤버함수를 델리게이트에 추가한다.

Remove() : 멀티케스트 델리게이트에 등록된 함수를 제거한다.

RemoveAll() : 모든 함수를 제거한다.

Broadcast() : 등록된 모든 함수를 호출한다.



https://docs.unrealengine.com/5.0/ko/delegates-and-lamba-functions-in-unreal-engine/

-------------------------------

CreateDefaultSubobject : 생성자 전용 함수이다. 생성자에서 컴포넌트를 생성하기 위한 함수이다.



----------------------------------
일시적인 공격용 충돌체 생성
	// 
	// Sweep과 Overlap 2가지 종류로 나뉜다.
	// 여기서 Sweep과 Overlap은 Single과 Multi 2가지로 나뉜다.
	// Single은 가장 먼저 충돌한 하나의 객체에, Multi는 충돌된 모든 물체에 대해 충돌.
	// Trace 충돌채널을 이용해서 충돌을 진행한다.
	// 이 함수는 반환값으로 충돌이 있을 경우 true, 없을 경우 false를 반환한다.

----------------------------------

FModel : 사운드 관련 외부 라이브러리

----------------------------------

런타임 에셋로드

동기화 로딩 :

비동기화 로딩 :

----------------------------------

언리얼은 사운드는 .wave 사용

----------------------------------

ProjectileMovement는 액터 컴포넌트? 여서 계층구조로 안들어감.

초기 속도 값이 있으면 아래 속도값(Velocity)은 노말라이즈됨.
----------------------------------

FActorSpawnParameters ActorParam;
ActorParam.SpawnCollisionHandlingOverride = 
	ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButDontSpawnIfColliding;

// Template 변수에 특정 액터를 넣어주면 해당 액터를 복제한 액터를 생성해준다.
// ActorParam.Template


----------------------------------
Player 용 Pawn은 메모리에서 제거하면 가지고 있던 모든 데이터가 제거가 된다. 
하지만 PlayerState는 메모리에 그대로 남아있는다.
즉, 데이터를 다음 월드에서도 유지해야 한다면 PlayerState를 활용하여 데이터를 저장해야 한다.
----------------------------------

비헤이비어 트리


셀랙트는 자손이 하나라도 성공하면 성공, 모두 실패하면 실패.

시퀀서는 자손이 하나라도 실패하면 더이상 형제로 않가고 실패, 성공하면 다음으로 셀렉터와 반대.

Simple Parallel 병렬처리용.


데코레이터: 조건 검사로 노드의 성공실패 여부를 판단해 줄 수 있음.
서비스: 노드에 추가적인 기능을 부여.

둘다 직접 만들 수 있는데, 새 서비스를 누르면 블루프린트로 만들 수 있음.
c++로 만들려면 Build.cs에 "AIModule"을 추가해줘야함.


데코레이터가 있으면 요청중단이 있을때 까지는 계속 동작함.


----------------------------------

블랙보드는 AI동작에 필요한 데이터를 저장하는 곳.
비헤이비어 트리는 AI가 어떻게 동작할지 정하는 곳.
